// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"context"
	"github.com/ONSdigital/dis-migration-service/domain"
	"github.com/ONSdigital/dis-migration-service/executor"
	"sync"
)

// Ensure, that TaskExecutorMock does implement executor.TaskExecutor.
// If this is not the case, regenerate this file with moq.
var _ executor.TaskExecutor = &TaskExecutorMock{}

// TaskExecutorMock is a mock implementation of executor.TaskExecutor.
//
//	func TestSomethingThatUsesTaskExecutor(t *testing.T) {
//
//		// make and configure a mocked executor.TaskExecutor
//		mockedTaskExecutor := &TaskExecutorMock{
//			MigrateFunc: func(ctx context.Context, task *domain.Task) error {
//				panic("mock out the Migrate method")
//			},
//			PostPublishFunc: func(ctx context.Context, task *domain.Task) error {
//				panic("mock out the PostPublish method")
//			},
//			PublishFunc: func(ctx context.Context, task *domain.Task) error {
//				panic("mock out the Publish method")
//			},
//			RevertFunc: func(ctx context.Context, task *domain.Task) error {
//				panic("mock out the Revert method")
//			},
//		}
//
//		// use mockedTaskExecutor in code that requires executor.TaskExecutor
//		// and then make assertions.
//
//	}
type TaskExecutorMock struct {
	// MigrateFunc mocks the Migrate method.
	MigrateFunc func(ctx context.Context, task *domain.Task) error

	// PostPublishFunc mocks the PostPublish method.
	PostPublishFunc func(ctx context.Context, task *domain.Task) error

	// PublishFunc mocks the Publish method.
	PublishFunc func(ctx context.Context, task *domain.Task) error

	// RevertFunc mocks the Revert method.
	RevertFunc func(ctx context.Context, task *domain.Task) error

	// calls tracks calls to the methods.
	calls struct {
		// Migrate holds details about calls to the Migrate method.
		Migrate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Task is the task argument value.
			Task *domain.Task
		}
		// PostPublish holds details about calls to the PostPublish method.
		PostPublish []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Task is the task argument value.
			Task *domain.Task
		}
		// Publish holds details about calls to the Publish method.
		Publish []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Task is the task argument value.
			Task *domain.Task
		}
		// Revert holds details about calls to the Revert method.
		Revert []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Task is the task argument value.
			Task *domain.Task
		}
	}
	lockMigrate     sync.RWMutex
	lockPostPublish sync.RWMutex
	lockPublish     sync.RWMutex
	lockRevert      sync.RWMutex
}

// Migrate calls MigrateFunc.
func (mock *TaskExecutorMock) Migrate(ctx context.Context, task *domain.Task) error {
	if mock.MigrateFunc == nil {
		panic("TaskExecutorMock.MigrateFunc: method is nil but TaskExecutor.Migrate was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Task *domain.Task
	}{
		Ctx:  ctx,
		Task: task,
	}
	mock.lockMigrate.Lock()
	mock.calls.Migrate = append(mock.calls.Migrate, callInfo)
	mock.lockMigrate.Unlock()
	return mock.MigrateFunc(ctx, task)
}

// MigrateCalls gets all the calls that were made to Migrate.
// Check the length with:
//
//	len(mockedTaskExecutor.MigrateCalls())
func (mock *TaskExecutorMock) MigrateCalls() []struct {
	Ctx  context.Context
	Task *domain.Task
} {
	var calls []struct {
		Ctx  context.Context
		Task *domain.Task
	}
	mock.lockMigrate.RLock()
	calls = mock.calls.Migrate
	mock.lockMigrate.RUnlock()
	return calls
}

// PostPublish calls PostPublishFunc.
func (mock *TaskExecutorMock) PostPublish(ctx context.Context, task *domain.Task) error {
	if mock.PostPublishFunc == nil {
		panic("TaskExecutorMock.PostPublishFunc: method is nil but TaskExecutor.PostPublish was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Task *domain.Task
	}{
		Ctx:  ctx,
		Task: task,
	}
	mock.lockPostPublish.Lock()
	mock.calls.PostPublish = append(mock.calls.PostPublish, callInfo)
	mock.lockPostPublish.Unlock()
	return mock.PostPublishFunc(ctx, task)
}

// PostPublishCalls gets all the calls that were made to PostPublish.
// Check the length with:
//
//	len(mockedTaskExecutor.PostPublishCalls())
func (mock *TaskExecutorMock) PostPublishCalls() []struct {
	Ctx  context.Context
	Task *domain.Task
} {
	var calls []struct {
		Ctx  context.Context
		Task *domain.Task
	}
	mock.lockPostPublish.RLock()
	calls = mock.calls.PostPublish
	mock.lockPostPublish.RUnlock()
	return calls
}

// Publish calls PublishFunc.
func (mock *TaskExecutorMock) Publish(ctx context.Context, task *domain.Task) error {
	if mock.PublishFunc == nil {
		panic("TaskExecutorMock.PublishFunc: method is nil but TaskExecutor.Publish was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Task *domain.Task
	}{
		Ctx:  ctx,
		Task: task,
	}
	mock.lockPublish.Lock()
	mock.calls.Publish = append(mock.calls.Publish, callInfo)
	mock.lockPublish.Unlock()
	return mock.PublishFunc(ctx, task)
}

// PublishCalls gets all the calls that were made to Publish.
// Check the length with:
//
//	len(mockedTaskExecutor.PublishCalls())
func (mock *TaskExecutorMock) PublishCalls() []struct {
	Ctx  context.Context
	Task *domain.Task
} {
	var calls []struct {
		Ctx  context.Context
		Task *domain.Task
	}
	mock.lockPublish.RLock()
	calls = mock.calls.Publish
	mock.lockPublish.RUnlock()
	return calls
}

// Revert calls RevertFunc.
func (mock *TaskExecutorMock) Revert(ctx context.Context, task *domain.Task) error {
	if mock.RevertFunc == nil {
		panic("TaskExecutorMock.RevertFunc: method is nil but TaskExecutor.Revert was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Task *domain.Task
	}{
		Ctx:  ctx,
		Task: task,
	}
	mock.lockRevert.Lock()
	mock.calls.Revert = append(mock.calls.Revert, callInfo)
	mock.lockRevert.Unlock()
	return mock.RevertFunc(ctx, task)
}

// RevertCalls gets all the calls that were made to Revert.
// Check the length with:
//
//	len(mockedTaskExecutor.RevertCalls())
func (mock *TaskExecutorMock) RevertCalls() []struct {
	Ctx  context.Context
	Task *domain.Task
} {
	var calls []struct {
		Ctx  context.Context
		Task *domain.Task
	}
	mock.lockRevert.RLock()
	calls = mock.calls.Revert
	mock.lockRevert.RUnlock()
	return calls
}
