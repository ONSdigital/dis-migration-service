// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"context"
	"github.com/ONSdigital/dis-migration-service/domain"
	"github.com/ONSdigital/dis-migration-service/store"
	"github.com/ONSdigital/dp-healthcheck/healthcheck"
	"sync"
)

// Ensure, that StorerMock does implement store.Storer.
// If this is not the case, regenerate this file with moq.
var _ store.Storer = &StorerMock{}

// StorerMock is a mock implementation of store.Storer.
//
//	func TestSomethingThatUsesStorer(t *testing.T) {
//
//		// make and configure a mocked store.Storer
//		mockedStorer := &StorerMock{
//			CheckerFunc: func(ctx context.Context, state *healthcheck.CheckState) error {
//				panic("mock out the Checker method")
//			},
//			ClaimJobFunc: func(ctx context.Context, pendingState domain.JobState, activeState domain.JobState) (*domain.Job, error) {
//				panic("mock out the ClaimJob method")
//			},
//			ClaimTaskFunc: func(ctx context.Context, pendingState domain.TaskState, activeState domain.TaskState) (*domain.Task, error) {
//				panic("mock out the ClaimTask method")
//			},
//			CloseFunc: func(ctx context.Context) error {
//				panic("mock out the Close method")
//			},
//			CountEventsByJobIDFunc: func(ctx context.Context, jobID string) (int, error) {
//				panic("mock out the CountEventsByJobID method")
//			},
//			CountTasksByJobIDFunc: func(ctx context.Context, jobID string) (int, error) {
//				panic("mock out the CountTasksByJobID method")
//			},
//			CreateEventFunc: func(ctx context.Context, event *domain.Event) error {
//				panic("mock out the CreateEvent method")
//			},
//			CreateJobFunc: func(ctx context.Context, job *domain.Job) error {
//				panic("mock out the CreateJob method")
//			},
//			CreateTaskFunc: func(ctx context.Context, task *domain.Task) error {
//				panic("mock out the CreateTask method")
//			},
//			GetJobFunc: func(ctx context.Context, jobID string) (*domain.Job, error) {
//				panic("mock out the GetJob method")
//			},
//			GetJobEventsFunc: func(ctx context.Context, jobID string, limit int, offset int) ([]*domain.Event, int, error) {
//				panic("mock out the GetJobEvents method")
//			},
//			GetJobTasksFunc: func(ctx context.Context, jobID string, limit int, offset int) ([]*domain.Task, int, error) {
//				panic("mock out the GetJobTasks method")
//			},
//			GetJobsFunc: func(ctx context.Context, states []domain.JobState, limit int, offset int) ([]*domain.Job, int, error) {
//				panic("mock out the GetJobs method")
//			},
//			GetJobsByConfigAndStateFunc: func(ctx context.Context, jc *domain.JobConfig, states []domain.JobState, limit int, offset int) ([]*domain.Job, error) {
//				panic("mock out the GetJobsByConfigAndState method")
//			},
//			GetTaskFunc: func(ctx context.Context, taskID string) (*domain.Task, error) {
//				panic("mock out the GetTask method")
//			},
//			UpdateJobFunc: func(ctx context.Context, job *domain.Job) error {
//				panic("mock out the UpdateJob method")
//			},
//			UpdateTaskFunc: func(ctx context.Context, task *domain.Task) error {
//				panic("mock out the UpdateTask method")
//			},
//		}
//
//		// use mockedStorer in code that requires store.Storer
//		// and then make assertions.
//
//	}
type StorerMock struct {
	// CheckerFunc mocks the Checker method.
	CheckerFunc func(ctx context.Context, state *healthcheck.CheckState) error

	// ClaimJobFunc mocks the ClaimJob method.
	ClaimJobFunc func(ctx context.Context, pendingState domain.JobState, activeState domain.JobState) (*domain.Job, error)

	// ClaimTaskFunc mocks the ClaimTask method.
	ClaimTaskFunc func(ctx context.Context, pendingState domain.TaskState, activeState domain.TaskState) (*domain.Task, error)

	// CloseFunc mocks the Close method.
	CloseFunc func(ctx context.Context) error

	// CountEventsByJobIDFunc mocks the CountEventsByJobID method.
	CountEventsByJobIDFunc func(ctx context.Context, jobID string) (int, error)

	// CountTasksByJobIDFunc mocks the CountTasksByJobID method.
	CountTasksByJobIDFunc func(ctx context.Context, jobID string) (int, error)

	// CreateEventFunc mocks the CreateEvent method.
	CreateEventFunc func(ctx context.Context, event *domain.Event) error

	// CreateJobFunc mocks the CreateJob method.
	CreateJobFunc func(ctx context.Context, job *domain.Job) error

	// CreateTaskFunc mocks the CreateTask method.
	CreateTaskFunc func(ctx context.Context, task *domain.Task) error

	// GetJobFunc mocks the GetJob method.
	GetJobFunc func(ctx context.Context, jobID string) (*domain.Job, error)

	// GetJobEventsFunc mocks the GetJobEvents method.
	GetJobEventsFunc func(ctx context.Context, jobID string, limit int, offset int) ([]*domain.Event, int, error)

	// GetJobTasksFunc mocks the GetJobTasks method.
	GetJobTasksFunc func(ctx context.Context, jobID string, limit int, offset int) ([]*domain.Task, int, error)

	// GetJobsFunc mocks the GetJobs method.
	GetJobsFunc func(ctx context.Context, states []domain.JobState, limit int, offset int) ([]*domain.Job, int, error)

	// GetJobsByConfigAndStateFunc mocks the GetJobsByConfigAndState method.
	GetJobsByConfigAndStateFunc func(ctx context.Context, jc *domain.JobConfig, states []domain.JobState, limit int, offset int) ([]*domain.Job, error)

	// GetTaskFunc mocks the GetTask method.
	GetTaskFunc func(ctx context.Context, taskID string) (*domain.Task, error)

	// UpdateJobFunc mocks the UpdateJob method.
	UpdateJobFunc func(ctx context.Context, job *domain.Job) error

	// UpdateTaskFunc mocks the UpdateTask method.
	UpdateTaskFunc func(ctx context.Context, task *domain.Task) error

	// calls tracks calls to the methods.
	calls struct {
		// Checker holds details about calls to the Checker method.
		Checker []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// State is the state argument value.
			State *healthcheck.CheckState
		}
		// ClaimJob holds details about calls to the ClaimJob method.
		ClaimJob []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// PendingState is the pendingState argument value.
			PendingState domain.JobState
			// ActiveState is the activeState argument value.
			ActiveState domain.JobState
		}
		// ClaimTask holds details about calls to the ClaimTask method.
		ClaimTask []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// PendingState is the pendingState argument value.
			PendingState domain.TaskState
			// ActiveState is the activeState argument value.
			ActiveState domain.TaskState
		}
		// Close holds details about calls to the Close method.
		Close []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// CountEventsByJobID holds details about calls to the CountEventsByJobID method.
		CountEventsByJobID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// JobID is the jobID argument value.
			JobID string
		}
		// CountTasksByJobID holds details about calls to the CountTasksByJobID method.
		CountTasksByJobID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// JobID is the jobID argument value.
			JobID string
		}
		// CreateEvent holds details about calls to the CreateEvent method.
		CreateEvent []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Event is the event argument value.
			Event *domain.Event
		}
		// CreateJob holds details about calls to the CreateJob method.
		CreateJob []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Job is the job argument value.
			Job *domain.Job
		}
		// CreateTask holds details about calls to the CreateTask method.
		CreateTask []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Task is the task argument value.
			Task *domain.Task
		}
		// GetJob holds details about calls to the GetJob method.
		GetJob []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// JobID is the jobID argument value.
			JobID string
		}
		// GetJobEvents holds details about calls to the GetJobEvents method.
		GetJobEvents []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// JobID is the jobID argument value.
			JobID string
			// Limit is the limit argument value.
			Limit int
			// Offset is the offset argument value.
			Offset int
		}
		// GetJobTasks holds details about calls to the GetJobTasks method.
		GetJobTasks []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// JobID is the jobID argument value.
			JobID string
			// Limit is the limit argument value.
			Limit int
			// Offset is the offset argument value.
			Offset int
		}
		// GetJobs holds details about calls to the GetJobs method.
		GetJobs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// States is the states argument value.
			States []domain.JobState
			// Limit is the limit argument value.
			Limit int
			// Offset is the offset argument value.
			Offset int
		}
		// GetJobsByConfigAndState holds details about calls to the GetJobsByConfigAndState method.
		GetJobsByConfigAndState []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Jc is the jc argument value.
			Jc *domain.JobConfig
			// States is the states argument value.
			States []domain.JobState
			// Limit is the limit argument value.
			Limit int
			// Offset is the offset argument value.
			Offset int
		}
		// GetTask holds details about calls to the GetTask method.
		GetTask []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TaskID is the taskID argument value.
			TaskID string
		}
		// UpdateJob holds details about calls to the UpdateJob method.
		UpdateJob []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Job is the job argument value.
			Job *domain.Job
		}
		// UpdateTask holds details about calls to the UpdateTask method.
		UpdateTask []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Task is the task argument value.
			Task *domain.Task
		}
	}
	lockChecker                 sync.RWMutex
	lockClaimJob                sync.RWMutex
	lockClaimTask               sync.RWMutex
	lockClose                   sync.RWMutex
	lockCountEventsByJobID      sync.RWMutex
	lockCountTasksByJobID       sync.RWMutex
	lockCreateEvent             sync.RWMutex
	lockCreateJob               sync.RWMutex
	lockCreateTask              sync.RWMutex
	lockGetJob                  sync.RWMutex
	lockGetJobEvents            sync.RWMutex
	lockGetJobTasks             sync.RWMutex
	lockGetJobs                 sync.RWMutex
	lockGetJobsByConfigAndState sync.RWMutex
	lockGetTask                 sync.RWMutex
	lockUpdateJob               sync.RWMutex
	lockUpdateTask              sync.RWMutex
}

// Checker calls CheckerFunc.
func (mock *StorerMock) Checker(ctx context.Context, state *healthcheck.CheckState) error {
	if mock.CheckerFunc == nil {
		panic("StorerMock.CheckerFunc: method is nil but Storer.Checker was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		State *healthcheck.CheckState
	}{
		Ctx:   ctx,
		State: state,
	}
	mock.lockChecker.Lock()
	mock.calls.Checker = append(mock.calls.Checker, callInfo)
	mock.lockChecker.Unlock()
	return mock.CheckerFunc(ctx, state)
}

// CheckerCalls gets all the calls that were made to Checker.
// Check the length with:
//
//	len(mockedStorer.CheckerCalls())
func (mock *StorerMock) CheckerCalls() []struct {
	Ctx   context.Context
	State *healthcheck.CheckState
} {
	var calls []struct {
		Ctx   context.Context
		State *healthcheck.CheckState
	}
	mock.lockChecker.RLock()
	calls = mock.calls.Checker
	mock.lockChecker.RUnlock()
	return calls
}

// ClaimJob calls ClaimJobFunc.
func (mock *StorerMock) ClaimJob(ctx context.Context, pendingState domain.JobState, activeState domain.JobState) (*domain.Job, error) {
	if mock.ClaimJobFunc == nil {
		panic("StorerMock.ClaimJobFunc: method is nil but Storer.ClaimJob was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		PendingState domain.JobState
		ActiveState  domain.JobState
	}{
		Ctx:          ctx,
		PendingState: pendingState,
		ActiveState:  activeState,
	}
	mock.lockClaimJob.Lock()
	mock.calls.ClaimJob = append(mock.calls.ClaimJob, callInfo)
	mock.lockClaimJob.Unlock()
	return mock.ClaimJobFunc(ctx, pendingState, activeState)
}

// ClaimJobCalls gets all the calls that were made to ClaimJob.
// Check the length with:
//
//	len(mockedStorer.ClaimJobCalls())
func (mock *StorerMock) ClaimJobCalls() []struct {
	Ctx          context.Context
	PendingState domain.JobState
	ActiveState  domain.JobState
} {
	var calls []struct {
		Ctx          context.Context
		PendingState domain.JobState
		ActiveState  domain.JobState
	}
	mock.lockClaimJob.RLock()
	calls = mock.calls.ClaimJob
	mock.lockClaimJob.RUnlock()
	return calls
}

// ClaimTask calls ClaimTaskFunc.
func (mock *StorerMock) ClaimTask(ctx context.Context, pendingState domain.TaskState, activeState domain.TaskState) (*domain.Task, error) {
	if mock.ClaimTaskFunc == nil {
		panic("StorerMock.ClaimTaskFunc: method is nil but Storer.ClaimTask was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		PendingState domain.TaskState
		ActiveState  domain.TaskState
	}{
		Ctx:          ctx,
		PendingState: pendingState,
		ActiveState:  activeState,
	}
	mock.lockClaimTask.Lock()
	mock.calls.ClaimTask = append(mock.calls.ClaimTask, callInfo)
	mock.lockClaimTask.Unlock()
	return mock.ClaimTaskFunc(ctx, pendingState, activeState)
}

// ClaimTaskCalls gets all the calls that were made to ClaimTask.
// Check the length with:
//
//	len(mockedStorer.ClaimTaskCalls())
func (mock *StorerMock) ClaimTaskCalls() []struct {
	Ctx          context.Context
	PendingState domain.TaskState
	ActiveState  domain.TaskState
} {
	var calls []struct {
		Ctx          context.Context
		PendingState domain.TaskState
		ActiveState  domain.TaskState
	}
	mock.lockClaimTask.RLock()
	calls = mock.calls.ClaimTask
	mock.lockClaimTask.RUnlock()
	return calls
}

// Close calls CloseFunc.
func (mock *StorerMock) Close(ctx context.Context) error {
	if mock.CloseFunc == nil {
		panic("StorerMock.CloseFunc: method is nil but Storer.Close was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	return mock.CloseFunc(ctx)
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//	len(mockedStorer.CloseCalls())
func (mock *StorerMock) CloseCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// CountEventsByJobID calls CountEventsByJobIDFunc.
func (mock *StorerMock) CountEventsByJobID(ctx context.Context, jobID string) (int, error) {
	if mock.CountEventsByJobIDFunc == nil {
		panic("StorerMock.CountEventsByJobIDFunc: method is nil but Storer.CountEventsByJobID was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		JobID string
	}{
		Ctx:   ctx,
		JobID: jobID,
	}
	mock.lockCountEventsByJobID.Lock()
	mock.calls.CountEventsByJobID = append(mock.calls.CountEventsByJobID, callInfo)
	mock.lockCountEventsByJobID.Unlock()
	return mock.CountEventsByJobIDFunc(ctx, jobID)
}

// CountEventsByJobIDCalls gets all the calls that were made to CountEventsByJobID.
// Check the length with:
//
//	len(mockedStorer.CountEventsByJobIDCalls())
func (mock *StorerMock) CountEventsByJobIDCalls() []struct {
	Ctx   context.Context
	JobID string
} {
	var calls []struct {
		Ctx   context.Context
		JobID string
	}
	mock.lockCountEventsByJobID.RLock()
	calls = mock.calls.CountEventsByJobID
	mock.lockCountEventsByJobID.RUnlock()
	return calls
}

// CountTasksByJobID calls CountTasksByJobIDFunc.
func (mock *StorerMock) CountTasksByJobID(ctx context.Context, jobID string) (int, error) {
	if mock.CountTasksByJobIDFunc == nil {
		panic("StorerMock.CountTasksByJobIDFunc: method is nil but Storer.CountTasksByJobID was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		JobID string
	}{
		Ctx:   ctx,
		JobID: jobID,
	}
	mock.lockCountTasksByJobID.Lock()
	mock.calls.CountTasksByJobID = append(mock.calls.CountTasksByJobID, callInfo)
	mock.lockCountTasksByJobID.Unlock()
	return mock.CountTasksByJobIDFunc(ctx, jobID)
}

// CountTasksByJobIDCalls gets all the calls that were made to CountTasksByJobID.
// Check the length with:
//
//	len(mockedStorer.CountTasksByJobIDCalls())
func (mock *StorerMock) CountTasksByJobIDCalls() []struct {
	Ctx   context.Context
	JobID string
} {
	var calls []struct {
		Ctx   context.Context
		JobID string
	}
	mock.lockCountTasksByJobID.RLock()
	calls = mock.calls.CountTasksByJobID
	mock.lockCountTasksByJobID.RUnlock()
	return calls
}

// CreateEvent calls CreateEventFunc.
func (mock *StorerMock) CreateEvent(ctx context.Context, event *domain.Event) error {
	if mock.CreateEventFunc == nil {
		panic("StorerMock.CreateEventFunc: method is nil but Storer.CreateEvent was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Event *domain.Event
	}{
		Ctx:   ctx,
		Event: event,
	}
	mock.lockCreateEvent.Lock()
	mock.calls.CreateEvent = append(mock.calls.CreateEvent, callInfo)
	mock.lockCreateEvent.Unlock()
	return mock.CreateEventFunc(ctx, event)
}

// CreateEventCalls gets all the calls that were made to CreateEvent.
// Check the length with:
//
//	len(mockedStorer.CreateEventCalls())
func (mock *StorerMock) CreateEventCalls() []struct {
	Ctx   context.Context
	Event *domain.Event
} {
	var calls []struct {
		Ctx   context.Context
		Event *domain.Event
	}
	mock.lockCreateEvent.RLock()
	calls = mock.calls.CreateEvent
	mock.lockCreateEvent.RUnlock()
	return calls
}

// CreateJob calls CreateJobFunc.
func (mock *StorerMock) CreateJob(ctx context.Context, job *domain.Job) error {
	if mock.CreateJobFunc == nil {
		panic("StorerMock.CreateJobFunc: method is nil but Storer.CreateJob was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Job *domain.Job
	}{
		Ctx: ctx,
		Job: job,
	}
	mock.lockCreateJob.Lock()
	mock.calls.CreateJob = append(mock.calls.CreateJob, callInfo)
	mock.lockCreateJob.Unlock()
	return mock.CreateJobFunc(ctx, job)
}

// CreateJobCalls gets all the calls that were made to CreateJob.
// Check the length with:
//
//	len(mockedStorer.CreateJobCalls())
func (mock *StorerMock) CreateJobCalls() []struct {
	Ctx context.Context
	Job *domain.Job
} {
	var calls []struct {
		Ctx context.Context
		Job *domain.Job
	}
	mock.lockCreateJob.RLock()
	calls = mock.calls.CreateJob
	mock.lockCreateJob.RUnlock()
	return calls
}

// CreateTask calls CreateTaskFunc.
func (mock *StorerMock) CreateTask(ctx context.Context, task *domain.Task) error {
	if mock.CreateTaskFunc == nil {
		panic("StorerMock.CreateTaskFunc: method is nil but Storer.CreateTask was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Task *domain.Task
	}{
		Ctx:  ctx,
		Task: task,
	}
	mock.lockCreateTask.Lock()
	mock.calls.CreateTask = append(mock.calls.CreateTask, callInfo)
	mock.lockCreateTask.Unlock()
	return mock.CreateTaskFunc(ctx, task)
}

// CreateTaskCalls gets all the calls that were made to CreateTask.
// Check the length with:
//
//	len(mockedStorer.CreateTaskCalls())
func (mock *StorerMock) CreateTaskCalls() []struct {
	Ctx  context.Context
	Task *domain.Task
} {
	var calls []struct {
		Ctx  context.Context
		Task *domain.Task
	}
	mock.lockCreateTask.RLock()
	calls = mock.calls.CreateTask
	mock.lockCreateTask.RUnlock()
	return calls
}

// GetJob calls GetJobFunc.
func (mock *StorerMock) GetJob(ctx context.Context, jobID string) (*domain.Job, error) {
	if mock.GetJobFunc == nil {
		panic("StorerMock.GetJobFunc: method is nil but Storer.GetJob was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		JobID string
	}{
		Ctx:   ctx,
		JobID: jobID,
	}
	mock.lockGetJob.Lock()
	mock.calls.GetJob = append(mock.calls.GetJob, callInfo)
	mock.lockGetJob.Unlock()
	return mock.GetJobFunc(ctx, jobID)
}

// GetJobCalls gets all the calls that were made to GetJob.
// Check the length with:
//
//	len(mockedStorer.GetJobCalls())
func (mock *StorerMock) GetJobCalls() []struct {
	Ctx   context.Context
	JobID string
} {
	var calls []struct {
		Ctx   context.Context
		JobID string
	}
	mock.lockGetJob.RLock()
	calls = mock.calls.GetJob
	mock.lockGetJob.RUnlock()
	return calls
}

// GetJobEvents calls GetJobEventsFunc.
func (mock *StorerMock) GetJobEvents(ctx context.Context, jobID string, limit int, offset int) ([]*domain.Event, int, error) {
	if mock.GetJobEventsFunc == nil {
		panic("StorerMock.GetJobEventsFunc: method is nil but Storer.GetJobEvents was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		JobID  string
		Limit  int
		Offset int
	}{
		Ctx:    ctx,
		JobID:  jobID,
		Limit:  limit,
		Offset: offset,
	}
	mock.lockGetJobEvents.Lock()
	mock.calls.GetJobEvents = append(mock.calls.GetJobEvents, callInfo)
	mock.lockGetJobEvents.Unlock()
	return mock.GetJobEventsFunc(ctx, jobID, limit, offset)
}

// GetJobEventsCalls gets all the calls that were made to GetJobEvents.
// Check the length with:
//
//	len(mockedStorer.GetJobEventsCalls())
func (mock *StorerMock) GetJobEventsCalls() []struct {
	Ctx    context.Context
	JobID  string
	Limit  int
	Offset int
} {
	var calls []struct {
		Ctx    context.Context
		JobID  string
		Limit  int
		Offset int
	}
	mock.lockGetJobEvents.RLock()
	calls = mock.calls.GetJobEvents
	mock.lockGetJobEvents.RUnlock()
	return calls
}

// GetJobTasks calls GetJobTasksFunc.
func (mock *StorerMock) GetJobTasks(ctx context.Context, jobID string, limit int, offset int) ([]*domain.Task, int, error) {
	if mock.GetJobTasksFunc == nil {
		panic("StorerMock.GetJobTasksFunc: method is nil but Storer.GetJobTasks was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		JobID  string
		Limit  int
		Offset int
	}{
		Ctx:    ctx,
		JobID:  jobID,
		Limit:  limit,
		Offset: offset,
	}
	mock.lockGetJobTasks.Lock()
	mock.calls.GetJobTasks = append(mock.calls.GetJobTasks, callInfo)
	mock.lockGetJobTasks.Unlock()
	return mock.GetJobTasksFunc(ctx, jobID, limit, offset)
}

// GetJobTasksCalls gets all the calls that were made to GetJobTasks.
// Check the length with:
//
//	len(mockedStorer.GetJobTasksCalls())
func (mock *StorerMock) GetJobTasksCalls() []struct {
	Ctx    context.Context
	JobID  string
	Limit  int
	Offset int
} {
	var calls []struct {
		Ctx    context.Context
		JobID  string
		Limit  int
		Offset int
	}
	mock.lockGetJobTasks.RLock()
	calls = mock.calls.GetJobTasks
	mock.lockGetJobTasks.RUnlock()
	return calls
}

// GetJobs calls GetJobsFunc.
func (mock *StorerMock) GetJobs(ctx context.Context, states []domain.JobState, limit int, offset int) ([]*domain.Job, int, error) {
	if mock.GetJobsFunc == nil {
		panic("StorerMock.GetJobsFunc: method is nil but Storer.GetJobs was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		States []domain.JobState
		Limit  int
		Offset int
	}{
		Ctx:    ctx,
		States: states,
		Limit:  limit,
		Offset: offset,
	}
	mock.lockGetJobs.Lock()
	mock.calls.GetJobs = append(mock.calls.GetJobs, callInfo)
	mock.lockGetJobs.Unlock()
	return mock.GetJobsFunc(ctx, states, limit, offset)
}

// GetJobsCalls gets all the calls that were made to GetJobs.
// Check the length with:
//
//	len(mockedStorer.GetJobsCalls())
func (mock *StorerMock) GetJobsCalls() []struct {
	Ctx    context.Context
	States []domain.JobState
	Limit  int
	Offset int
} {
	var calls []struct {
		Ctx    context.Context
		States []domain.JobState
		Limit  int
		Offset int
	}
	mock.lockGetJobs.RLock()
	calls = mock.calls.GetJobs
	mock.lockGetJobs.RUnlock()
	return calls
}

// GetJobsByConfigAndState calls GetJobsByConfigAndStateFunc.
func (mock *StorerMock) GetJobsByConfigAndState(ctx context.Context, jc *domain.JobConfig, states []domain.JobState, limit int, offset int) ([]*domain.Job, error) {
	if mock.GetJobsByConfigAndStateFunc == nil {
		panic("StorerMock.GetJobsByConfigAndStateFunc: method is nil but Storer.GetJobsByConfigAndState was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Jc     *domain.JobConfig
		States []domain.JobState
		Limit  int
		Offset int
	}{
		Ctx:    ctx,
		Jc:     jc,
		States: states,
		Limit:  limit,
		Offset: offset,
	}
	mock.lockGetJobsByConfigAndState.Lock()
	mock.calls.GetJobsByConfigAndState = append(mock.calls.GetJobsByConfigAndState, callInfo)
	mock.lockGetJobsByConfigAndState.Unlock()
	return mock.GetJobsByConfigAndStateFunc(ctx, jc, states, limit, offset)
}

// GetJobsByConfigAndStateCalls gets all the calls that were made to GetJobsByConfigAndState.
// Check the length with:
//
//	len(mockedStorer.GetJobsByConfigAndStateCalls())
func (mock *StorerMock) GetJobsByConfigAndStateCalls() []struct {
	Ctx    context.Context
	Jc     *domain.JobConfig
	States []domain.JobState
	Limit  int
	Offset int
} {
	var calls []struct {
		Ctx    context.Context
		Jc     *domain.JobConfig
		States []domain.JobState
		Limit  int
		Offset int
	}
	mock.lockGetJobsByConfigAndState.RLock()
	calls = mock.calls.GetJobsByConfigAndState
	mock.lockGetJobsByConfigAndState.RUnlock()
	return calls
}

// GetTask calls GetTaskFunc.
func (mock *StorerMock) GetTask(ctx context.Context, taskID string) (*domain.Task, error) {
	if mock.GetTaskFunc == nil {
		panic("StorerMock.GetTaskFunc: method is nil but Storer.GetTask was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		TaskID string
	}{
		Ctx:    ctx,
		TaskID: taskID,
	}
	mock.lockGetTask.Lock()
	mock.calls.GetTask = append(mock.calls.GetTask, callInfo)
	mock.lockGetTask.Unlock()
	return mock.GetTaskFunc(ctx, taskID)
}

// GetTaskCalls gets all the calls that were made to GetTask.
// Check the length with:
//
//	len(mockedStorer.GetTaskCalls())
func (mock *StorerMock) GetTaskCalls() []struct {
	Ctx    context.Context
	TaskID string
} {
	var calls []struct {
		Ctx    context.Context
		TaskID string
	}
	mock.lockGetTask.RLock()
	calls = mock.calls.GetTask
	mock.lockGetTask.RUnlock()
	return calls
}

// UpdateJob calls UpdateJobFunc.
func (mock *StorerMock) UpdateJob(ctx context.Context, job *domain.Job) error {
	if mock.UpdateJobFunc == nil {
		panic("StorerMock.UpdateJobFunc: method is nil but Storer.UpdateJob was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Job *domain.Job
	}{
		Ctx: ctx,
		Job: job,
	}
	mock.lockUpdateJob.Lock()
	mock.calls.UpdateJob = append(mock.calls.UpdateJob, callInfo)
	mock.lockUpdateJob.Unlock()
	return mock.UpdateJobFunc(ctx, job)
}

// UpdateJobCalls gets all the calls that were made to UpdateJob.
// Check the length with:
//
//	len(mockedStorer.UpdateJobCalls())
func (mock *StorerMock) UpdateJobCalls() []struct {
	Ctx context.Context
	Job *domain.Job
} {
	var calls []struct {
		Ctx context.Context
		Job *domain.Job
	}
	mock.lockUpdateJob.RLock()
	calls = mock.calls.UpdateJob
	mock.lockUpdateJob.RUnlock()
	return calls
}

// UpdateTask calls UpdateTaskFunc.
func (mock *StorerMock) UpdateTask(ctx context.Context, task *domain.Task) error {
	if mock.UpdateTaskFunc == nil {
		panic("StorerMock.UpdateTaskFunc: method is nil but Storer.UpdateTask was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Task *domain.Task
	}{
		Ctx:  ctx,
		Task: task,
	}
	mock.lockUpdateTask.Lock()
	mock.calls.UpdateTask = append(mock.calls.UpdateTask, callInfo)
	mock.lockUpdateTask.Unlock()
	return mock.UpdateTaskFunc(ctx, task)
}

// UpdateTaskCalls gets all the calls that were made to UpdateTask.
// Check the length with:
//
//	len(mockedStorer.UpdateTaskCalls())
func (mock *StorerMock) UpdateTaskCalls() []struct {
	Ctx  context.Context
	Task *domain.Task
} {
	var calls []struct {
		Ctx  context.Context
		Task *domain.Task
	}
	mock.lockUpdateTask.RLock()
	calls = mock.calls.UpdateTask
	mock.lockUpdateTask.RUnlock()
	return calls
}
