// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"context"
	"github.com/ONSdigital/dis-migration-service/mongo"
	"sync"
)

// Ensure, that MongoConnectionMock does implement mongo.MongoConnection.
// If this is not the case, regenerate this file with moq.
var _ mongo.MongoConnection = &MongoConnectionMock{}

// MongoConnectionMock is a mock implementation of mongo.MongoConnection.
//
//	func TestSomethingThatUsesMongoConnection(t *testing.T) {
//
//		// make and configure a mocked mongo.MongoConnection
//		mockedMongoConnection := &MongoConnectionMock{
//			CollectionFunc: func(name string) mongo.MongoCollection {
//				panic("mock out the Collection method")
//			},
//			ListCollectionsForFunc: func(ctx context.Context, database string) ([]string, error) {
//				panic("mock out the ListCollectionsFor method")
//			},
//			RunCommandFunc: func(ctx context.Context, command interface{}) error {
//				panic("mock out the RunCommand method")
//			},
//		}
//
//		// use mockedMongoConnection in code that requires mongo.MongoConnection
//		// and then make assertions.
//
//	}
type MongoConnectionMock struct {
	// CollectionFunc mocks the Collection method.
	CollectionFunc func(name string) mongo.MongoCollection

	// ListCollectionsForFunc mocks the ListCollectionsFor method.
	ListCollectionsForFunc func(ctx context.Context, database string) ([]string, error)

	// RunCommandFunc mocks the RunCommand method.
	RunCommandFunc func(ctx context.Context, command interface{}) error

	// calls tracks calls to the methods.
	calls struct {
		// Collection holds details about calls to the Collection method.
		Collection []struct {
			// Name is the name argument value.
			Name string
		}
		// ListCollectionsFor holds details about calls to the ListCollectionsFor method.
		ListCollectionsFor []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Database is the database argument value.
			Database string
		}
		// RunCommand holds details about calls to the RunCommand method.
		RunCommand []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Command is the command argument value.
			Command interface{}
		}
	}
	lockCollection         sync.RWMutex
	lockListCollectionsFor sync.RWMutex
	lockRunCommand         sync.RWMutex
}

// Collection calls CollectionFunc.
func (mock *MongoConnectionMock) Collection(name string) mongo.MongoCollection {
	if mock.CollectionFunc == nil {
		panic("MongoConnectionMock.CollectionFunc: method is nil but MongoConnection.Collection was just called")
	}
	callInfo := struct {
		Name string
	}{
		Name: name,
	}
	mock.lockCollection.Lock()
	mock.calls.Collection = append(mock.calls.Collection, callInfo)
	mock.lockCollection.Unlock()
	return mock.CollectionFunc(name)
}

// CollectionCalls gets all the calls that were made to Collection.
// Check the length with:
//
//	len(mockedMongoConnection.CollectionCalls())
func (mock *MongoConnectionMock) CollectionCalls() []struct {
	Name string
} {
	var calls []struct {
		Name string
	}
	mock.lockCollection.RLock()
	calls = mock.calls.Collection
	mock.lockCollection.RUnlock()
	return calls
}

// ListCollectionsFor calls ListCollectionsForFunc.
func (mock *MongoConnectionMock) ListCollectionsFor(ctx context.Context, database string) ([]string, error) {
	if mock.ListCollectionsForFunc == nil {
		panic("MongoConnectionMock.ListCollectionsForFunc: method is nil but MongoConnection.ListCollectionsFor was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Database string
	}{
		Ctx:      ctx,
		Database: database,
	}
	mock.lockListCollectionsFor.Lock()
	mock.calls.ListCollectionsFor = append(mock.calls.ListCollectionsFor, callInfo)
	mock.lockListCollectionsFor.Unlock()
	return mock.ListCollectionsForFunc(ctx, database)
}

// ListCollectionsForCalls gets all the calls that were made to ListCollectionsFor.
// Check the length with:
//
//	len(mockedMongoConnection.ListCollectionsForCalls())
func (mock *MongoConnectionMock) ListCollectionsForCalls() []struct {
	Ctx      context.Context
	Database string
} {
	var calls []struct {
		Ctx      context.Context
		Database string
	}
	mock.lockListCollectionsFor.RLock()
	calls = mock.calls.ListCollectionsFor
	mock.lockListCollectionsFor.RUnlock()
	return calls
}

// RunCommand calls RunCommandFunc.
func (mock *MongoConnectionMock) RunCommand(ctx context.Context, command interface{}) error {
	if mock.RunCommandFunc == nil {
		panic("MongoConnectionMock.RunCommandFunc: method is nil but MongoConnection.RunCommand was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Command interface{}
	}{
		Ctx:     ctx,
		Command: command,
	}
	mock.lockRunCommand.Lock()
	mock.calls.RunCommand = append(mock.calls.RunCommand, callInfo)
	mock.lockRunCommand.Unlock()
	return mock.RunCommandFunc(ctx, command)
}

// RunCommandCalls gets all the calls that were made to RunCommand.
// Check the length with:
//
//	len(mockedMongoConnection.RunCommandCalls())
func (mock *MongoConnectionMock) RunCommandCalls() []struct {
	Ctx     context.Context
	Command interface{}
} {
	var calls []struct {
		Ctx     context.Context
		Command interface{}
	}
	mock.lockRunCommand.RLock()
	calls = mock.calls.RunCommand
	mock.lockRunCommand.RUnlock()
	return calls
}
