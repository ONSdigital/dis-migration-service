// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"context"
	dismigrationservicemongo "github.com/ONSdigital/dis-migration-service/mongo"
	mondrivermongo "go.mongodb.org/mongo-driver/mongo"
	"sync"
)

// Ensure, that MongoCollectionMock does implement dismigrationservicemongo.MongoCollection.
// If this is not the case, regenerate this file with moq.
var _ dismigrationservicemongo.MongoCollection = &MongoCollectionMock{}

// MongoCollectionMock is a mock implementation of dismigrationservicemongo.MongoCollection.
//
//	func TestSomethingThatUsesMongoCollection(t *testing.T) {
//
//		// make and configure a mocked dismigrationservicemongo.MongoCollection
//		mockedMongoCollection := &MongoCollectionMock{
//			FindFunc: func(ctx context.Context, filter interface{}, results interface{}, opts ...interface{}) (int, error) {
//				panic("mock out the Find method")
//			},
//			FindOneFunc: func(ctx context.Context, filter interface{}, result interface{}, opts ...interface{}) error {
//				panic("mock out the FindOne method")
//			},
//			FindOneAndUpdateFunc: func(ctx context.Context, filter interface{}, update interface{}, result interface{}, opts ...interface{}) error {
//				panic("mock out the FindOneAndUpdate method")
//			},
//			InsertOneFunc: func(ctx context.Context, document interface{}) (*mondrivermongo.InsertOneResult, error) {
//				panic("mock out the InsertOne method")
//			},
//			UpdateOneFunc: func(ctx context.Context, filter interface{}, update interface{}, opts ...interface{}) (*mondrivermongo.UpdateResult, error) {
//				panic("mock out the UpdateOne method")
//			},
//		}
//
//		// use mockedMongoCollection in code that requires dismigrationservicemongo.MongoCollection
//		// and then make assertions.
//
//	}
type MongoCollectionMock struct {
	// FindFunc mocks the Find method.
	FindFunc func(ctx context.Context, filter interface{}, results interface{}, opts ...interface{}) (int, error)

	// FindOneFunc mocks the FindOne method.
	FindOneFunc func(ctx context.Context, filter interface{}, result interface{}, opts ...interface{}) error

	// FindOneAndUpdateFunc mocks the FindOneAndUpdate method.
	FindOneAndUpdateFunc func(ctx context.Context, filter interface{}, update interface{}, result interface{}, opts ...interface{}) error

	// InsertOneFunc mocks the InsertOne method.
	InsertOneFunc func(ctx context.Context, document interface{}) (*mondrivermongo.InsertOneResult, error)

	// UpdateOneFunc mocks the UpdateOne method.
	UpdateOneFunc func(ctx context.Context, filter interface{}, update interface{}, opts ...interface{}) (*mondrivermongo.UpdateResult, error)

	// calls tracks calls to the methods.
	calls struct {
		// Find holds details about calls to the Find method.
		Find []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Filter is the filter argument value.
			Filter interface{}
			// Results is the results argument value.
			Results interface{}
			// Opts is the opts argument value.
			Opts []interface{}
		}
		// FindOne holds details about calls to the FindOne method.
		FindOne []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Filter is the filter argument value.
			Filter interface{}
			// Result is the result argument value.
			Result interface{}
			// Opts is the opts argument value.
			Opts []interface{}
		}
		// FindOneAndUpdate holds details about calls to the FindOneAndUpdate method.
		FindOneAndUpdate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Filter is the filter argument value.
			Filter interface{}
			// Update is the update argument value.
			Update interface{}
			// Result is the result argument value.
			Result interface{}
			// Opts is the opts argument value.
			Opts []interface{}
		}
		// InsertOne holds details about calls to the InsertOne method.
		InsertOne []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Document is the document argument value.
			Document interface{}
		}
		// UpdateOne holds details about calls to the UpdateOne method.
		UpdateOne []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Filter is the filter argument value.
			Filter interface{}
			// Update is the update argument value.
			Update interface{}
			// Opts is the opts argument value.
			Opts []interface{}
		}
	}
	lockFind             sync.RWMutex
	lockFindOne          sync.RWMutex
	lockFindOneAndUpdate sync.RWMutex
	lockInsertOne        sync.RWMutex
	lockUpdateOne        sync.RWMutex
}

// Find calls FindFunc.
func (mock *MongoCollectionMock) Find(ctx context.Context, filter interface{}, results interface{}, opts ...interface{}) (int, error) {
	if mock.FindFunc == nil {
		panic("MongoCollectionMock.FindFunc: method is nil but MongoCollection.Find was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Filter  interface{}
		Results interface{}
		Opts    []interface{}
	}{
		Ctx:     ctx,
		Filter:  filter,
		Results: results,
		Opts:    opts,
	}
	mock.lockFind.Lock()
	mock.calls.Find = append(mock.calls.Find, callInfo)
	mock.lockFind.Unlock()
	return mock.FindFunc(ctx, filter, results, opts...)
}

// FindCalls gets all the calls that were made to Find.
// Check the length with:
//
//	len(mockedMongoCollection.FindCalls())
func (mock *MongoCollectionMock) FindCalls() []struct {
	Ctx     context.Context
	Filter  interface{}
	Results interface{}
	Opts    []interface{}
} {
	var calls []struct {
		Ctx     context.Context
		Filter  interface{}
		Results interface{}
		Opts    []interface{}
	}
	mock.lockFind.RLock()
	calls = mock.calls.Find
	mock.lockFind.RUnlock()
	return calls
}

// FindOne calls FindOneFunc.
func (mock *MongoCollectionMock) FindOne(ctx context.Context, filter interface{}, result interface{}, opts ...interface{}) error {
	if mock.FindOneFunc == nil {
		panic("MongoCollectionMock.FindOneFunc: method is nil but MongoCollection.FindOne was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Filter interface{}
		Result interface{}
		Opts   []interface{}
	}{
		Ctx:    ctx,
		Filter: filter,
		Result: result,
		Opts:   opts,
	}
	mock.lockFindOne.Lock()
	mock.calls.FindOne = append(mock.calls.FindOne, callInfo)
	mock.lockFindOne.Unlock()
	return mock.FindOneFunc(ctx, filter, result, opts...)
}

// FindOneCalls gets all the calls that were made to FindOne.
// Check the length with:
//
//	len(mockedMongoCollection.FindOneCalls())
func (mock *MongoCollectionMock) FindOneCalls() []struct {
	Ctx    context.Context
	Filter interface{}
	Result interface{}
	Opts   []interface{}
} {
	var calls []struct {
		Ctx    context.Context
		Filter interface{}
		Result interface{}
		Opts   []interface{}
	}
	mock.lockFindOne.RLock()
	calls = mock.calls.FindOne
	mock.lockFindOne.RUnlock()
	return calls
}

// FindOneAndUpdate calls FindOneAndUpdateFunc.
func (mock *MongoCollectionMock) FindOneAndUpdate(ctx context.Context, filter interface{}, update interface{}, result interface{}, opts ...interface{}) error {
	if mock.FindOneAndUpdateFunc == nil {
		panic("MongoCollectionMock.FindOneAndUpdateFunc: method is nil but MongoCollection.FindOneAndUpdate was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Filter interface{}
		Update interface{}
		Result interface{}
		Opts   []interface{}
	}{
		Ctx:    ctx,
		Filter: filter,
		Update: update,
		Result: result,
		Opts:   opts,
	}
	mock.lockFindOneAndUpdate.Lock()
	mock.calls.FindOneAndUpdate = append(mock.calls.FindOneAndUpdate, callInfo)
	mock.lockFindOneAndUpdate.Unlock()
	return mock.FindOneAndUpdateFunc(ctx, filter, update, result, opts...)
}

// FindOneAndUpdateCalls gets all the calls that were made to FindOneAndUpdate.
// Check the length with:
//
//	len(mockedMongoCollection.FindOneAndUpdateCalls())
func (mock *MongoCollectionMock) FindOneAndUpdateCalls() []struct {
	Ctx    context.Context
	Filter interface{}
	Update interface{}
	Result interface{}
	Opts   []interface{}
} {
	var calls []struct {
		Ctx    context.Context
		Filter interface{}
		Update interface{}
		Result interface{}
		Opts   []interface{}
	}
	mock.lockFindOneAndUpdate.RLock()
	calls = mock.calls.FindOneAndUpdate
	mock.lockFindOneAndUpdate.RUnlock()
	return calls
}

// InsertOne calls InsertOneFunc.
func (mock *MongoCollectionMock) InsertOne(ctx context.Context, document interface{}) (*mondrivermongo.InsertOneResult, error) {
	if mock.InsertOneFunc == nil {
		panic("MongoCollectionMock.InsertOneFunc: method is nil but MongoCollection.InsertOne was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Document interface{}
	}{
		Ctx:      ctx,
		Document: document,
	}
	mock.lockInsertOne.Lock()
	mock.calls.InsertOne = append(mock.calls.InsertOne, callInfo)
	mock.lockInsertOne.Unlock()
	return mock.InsertOneFunc(ctx, document)
}

// InsertOneCalls gets all the calls that were made to InsertOne.
// Check the length with:
//
//	len(mockedMongoCollection.InsertOneCalls())
func (mock *MongoCollectionMock) InsertOneCalls() []struct {
	Ctx      context.Context
	Document interface{}
} {
	var calls []struct {
		Ctx      context.Context
		Document interface{}
	}
	mock.lockInsertOne.RLock()
	calls = mock.calls.InsertOne
	mock.lockInsertOne.RUnlock()
	return calls
}

// UpdateOne calls UpdateOneFunc.
func (mock *MongoCollectionMock) UpdateOne(ctx context.Context, filter interface{}, update interface{}, opts ...interface{}) (*mondrivermongo.UpdateResult, error) {
	if mock.UpdateOneFunc == nil {
		panic("MongoCollectionMock.UpdateOneFunc: method is nil but MongoCollection.UpdateOne was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Filter interface{}
		Update interface{}
		Opts   []interface{}
	}{
		Ctx:    ctx,
		Filter: filter,
		Update: update,
		Opts:   opts,
	}
	mock.lockUpdateOne.Lock()
	mock.calls.UpdateOne = append(mock.calls.UpdateOne, callInfo)
	mock.lockUpdateOne.Unlock()
	return mock.UpdateOneFunc(ctx, filter, update, opts...)
}

// UpdateOneCalls gets all the calls that were made to UpdateOne.
// Check the length with:
//
//	len(mockedMongoCollection.UpdateOneCalls())
func (mock *MongoCollectionMock) UpdateOneCalls() []struct {
	Ctx    context.Context
	Filter interface{}
	Update interface{}
	Opts   []interface{}
} {
	var calls []struct {
		Ctx    context.Context
		Filter interface{}
		Update interface{}
		Opts   []interface{}
	}
	mock.lockUpdateOne.RLock()
	calls = mock.calls.UpdateOne
	mock.lockUpdateOne.RUnlock()
	return calls
}
